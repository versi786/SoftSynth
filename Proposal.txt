Aasif Versi and Satya Bodduluri
Project Proposal

We would like to make a software sythesizer in Haskell for our final project. A synthesizer is an electronic musical intrument that generates electric signals that are converted to sound through an amplifier/speaker. A Software Synthesizer(SoftSynth) does the same thing but it produces the sounds digitally on a computer. There are four main parts to a synthesizer: Oscillator, LFO(Low Frequency Oscillator), Filter, Amplifier. These for parts are connected as shown here:  https://reverb-res.cloudinary.com/image/upload/c_scale,w_250/v1419878347/Map_pj27m0.jpg. Our overall goal is allow a user to create unique sounds that they could import into their own projects.

The oscillator is responsible for generating a base sound wave (sine, square, triangle, sawtooth, etc). The LFO is very similar to an oscillator but it oscillates at frequencies to low to hear. It is usually used to modulate the waves generated by the oscillators to create interesting effects. Filters come in flavors such as low-pass, high-pass, band, and notch to filter out different frequencies. Finally, the amplifiers shapes the final output of the sound. Both the amplifiers and the filters contain envelopes. Envelopes are made of attack, decay, sustain and release parts that dictate how the sound begins, sustains, and ends.

Use case:
  We want to make a general synthesizer library, where the different settings of the synthesizer can be controlled programatically. This will make it easy for someone else to create a gui and further extend the project. Our goal is to make it accessible both through the comandline and through the library interface.

Components:
  Oscillator
  LFO
  Filter
  Amplifier
  Envelope(s)
  Main - used to connect together the various parts, creating the final synth

Effort Budget
  More research into the different features of synthesizers (we know there are more features that we might be missing) and how they all fit together (10 hours)

  Choosing the correct data structures for working with audio (will probably have to revisit multiple times) (2 hours)

  Implementing the various parts (probably 5 hours for each part at least)

  Testing (3 hours)

  Connecting the different parts together (5 hours)

  Testing (3 hours)

  Refactoring (2 hours)

  Testing (2 hours)
